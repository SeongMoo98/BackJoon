/*
 * 기존의 소수를 판별하는 방법으로 풀면, 시간초과 에러가 납니다.
 * 소수를 빠르게 판별할 수 있는, 에라스토테네스의 체를 이용하여 소수리스트를 미리 구해놓고,
 * 주어진 최소값과 최대값에 따라 소수를 출력해야 합니다!
 * 에라스토테네스의 체 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한 다음, 소수로 밝혀진 숫자들의 배수를 지워나가며 하나씩 판별하는 방법
 * 1은 제외 =>2의 배수 지우기 =>3의 배수 지우기 =>4의 배수는 2의 배수에서 지워졌다 =>5의 배수 지우기 ...
 */
 
 void Eratos(int n)
{
    /*  만일 n이 1보다 작거나 같으면 함수 종료 */
    if (n <= 1) return;

    /*	2부터 n까지 n-1개를 저장할 수 있는 배열 할당
	배열 참조 번호와 소수와 일치하도록 배열의 크기는
	n+1 길이만큼 할당(인덱스 번호 0과 1은 사용하지 않음)	*/
	
	bool* PrimeArray = new bool[n + 1];

	/*  배열초기화: 처음엔 모두 소수로 보고 true값을 줌	*/
	for (int i = 2; i <= n; i++)
	    PrimeArray[i] = true;
	    
	    
	/*	에라토스테네스의 체에 맞게 소수를 구함
		만일, PrimeArray[i]가 true이면 i 이후의 i 배수는 약수로 i를
		가지고 있는 것이 되므로 i 이후의 i 배수에 대해 false값을 준다.
		PrimeArray[i]가 false이면 i는 이미 소수가 아니므로 i의 배수 역시
		소수가 아니게 된다. 그러므로 검사할 필요도 없다.
		또한 i*k (k < i) 까지는 이미 검사되었으므로 j시작 값은 i*2에서 i*i로 개선할 수 있다.	*/
		
	for (int i = 2; i * i <= n; i++){
		if (PrimeArray[i])
			for (int j = i * i; j <= n; j += i)
			    PrimeArray[j] = false;
	}
}
#include<iostream>
#include<cmath>
using namespace std;

int main(void)
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int Max, Min;
	cin >> Min >> Max;
	int* arr = new int[Max+1];

	for (int i = 0; i < Max+1; i++)
	{
		if (i < Min)
			arr[i] = 0;
		else
			arr[i] = i;
	}


	for (int i = 2; i <= sqrt(Max); i++)
		for (int j = i * 2; j <= Max; j += i)
			arr[j] = 0;


	for (int i = 0; i < Max+1; i++)
	{
		if(arr[i]==1)
			arr[i] = 0;

		if (arr[i] != 0)
			cout << arr[i] << "\n";
	}
	delete[]arr;

	return 0;
}
