#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
#include<memory.h>
using namespace std;

#define MAX 101


int N, M;						// 미로 크기
int matrix[MAX][MAX];			// 미로 표현용 2차원 배열
int visited[MAX][MAX];			// 방문 기록용 2차원 배열
int dist[MAX][MAX];				// 이동칸 기록용 2차원 배열

/*****/
int x_dir[4] = { -1,1,0,0 };	//상하좌우 x축 방향
int y_dir[4] = { 0,0,-1,1 };	//상하좌우 y축 방향

queue<pair<int, int>> q;		//탐색 좌표 저장용 queue
/*****/

//미로 경로 탐색
void bfs(int start_x, int start_y) {
	
	visited[start_x][start_y] = 1;
	q.push(make_pair(start_x, start_y));
	dist[start_x][start_y]++;				//시작 좌표까지 이동한 칸을 1로 지정

	//모든 좌표를 탐색할 때까지 반복
	while (!q.empty()) {
		
		// Queue의 front 좌표를 현재 좌표로 지정
		int x = q.front().first;
		int y = q.front().second;

		q.pop();

		//현재 좌표와 상하좌우로 인접한 좌표 확인
		for (int i = 0; i < 4; i++) {
			int x_new = x + x_dir[i];
			int y_new = y + y_dir[i];

			//인접한 좌표가 미로 내에 존재하는지, 방문한 적이 없는지, 이동이 가능한지 확인
			if ((x_new >= 0 && x_new < N) && (y_new >= 0 && y_new < M)
				&& (!visited[x_new][y_new]) && (matrix[x_new][y_new] == 1)) {

				visited[x_new][y_new] = 1;
				q.push(make_pair(x_new, y_new));
				dist[x_new][y_new] = dist[x][y] + 1;
			}
			

		}


	}
}

int main(void) {



	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	cin >> N >> M;

	for (int i = 0; i < N; i++) {
	
		string row;
		cin >> row;

		for (int j = 0; j < M; j++) {
			matrix[i][j] = row[j] - '0';
		}
	}
	

	bfs(0, 0);

	cout << dist[N - 1][M - 1];
	
	return 0;
}

