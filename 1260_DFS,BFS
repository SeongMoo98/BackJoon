#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
#include<memory.h>
using namespace std;

#define MAX 1001
int N, M;
int V;

bool visited[MAX] = { 0, };


//재귀를 이용한 DFS
void DFS(vector<int> * tree, int cur) {

	visited[cur] = true;
	cout << cur << " ";
	for (int i = 0; i < tree[cur].size(); i++) {
		//현재 Node와 연결된 Node를 저장
		int next_node = tree[cur][i];
		if (!visited[next_node]) {
			DFS(tree, next_node);
		}
	}
}

//Queue를 이용한 BFS
void BFS(vector<int>* tree, int cur) {
	queue<int> q;
	q.push(cur);
	visited[cur] = true;

	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		cout << cur << " ";
		for (int i = 0; i < tree[cur].size(); i++) {
			int next_node = tree[cur][i];
			if (!visited[next_node]) {
				visited[next_node] = true;
				q.push(next_node);
			}
		}
	}
}

int main(void) {


	ios_base::sync_with_stdio(false);
	cin.tie(NULL);


	cin >> N >> M >> V;

	vector<int>* tree = new vector<int>[N + 1];
	

	for (int i = 0; i < M; i++) {
		int start, end;
		cin >> start >> end;
		tree[start].push_back(end);
		tree[end].push_back(start);
	}


	/*vecto의 node가 정렬되어 있어야 한다!!!*/
	for (int i = 1; i <= N; i++) 
		sort(tree[i].begin(), tree[i].end());

	DFS(tree, V);
	cout << "\n";
	memset(visited, false, MAX);
	BFS(tree, V);
	
	return 0;
}

