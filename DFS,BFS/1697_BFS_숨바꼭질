import com.sun.source.tree.BinaryTree;
import com.sun.source.tree.ExpressionTree;
import com.sun.source.tree.TreeVisitor;

import java.io.*;
import java.lang.reflect.Array;
import java.util.*;
import static java.lang.Math.*;

public class Main {
    private final static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    final static Scanner sc = new Scanner(System.in);
    private final static StringBuilder sb = new StringBuilder();


    static int N;
    static int K;
    static int[] check = new int[100001];

    /** BFS 알고리즘으로 1차원 배열을 사용하여 푸는 문제 **/
    // 다음에 이동할 인덱스를 큐에 넣고 큐에서 꺼내면서 +1
    private static void BFS(int num){
        Queue<Integer> q = new LinkedList<>();
        q.add(num);
        check[num] = 0;

        while(!q.isEmpty()){
            int curr = q.poll();

            for(int i=0; i<3; i++){
                int next;

                if( i == 0 ) next = curr + 1;
                else if ( i == 1 ) next = curr - 1;
                else next = curr * 2;

                if(next == K) {
                    // 현재 최소 시간 1초 후 도착
                    System.out.println(check[curr] + 1);
                    return;
                }

                // next가 존재하고 범위를 넘지않으며
                // check[next] == 0 즉, 한번도 가지 않았던 곳
                if(next >=0 && next < check.length && check[next] == 0){
                    q.add(next);
                    check[next] = check[curr] + 1;
                }
            }
        }
    }
    public static void main(String[] args) throws IOException {

        N = sc.nextInt();
        K = sc.nextInt();

        if ( N == K ) System.out.println(0);
        else BFS(N);
        ㅁ



    }
}
