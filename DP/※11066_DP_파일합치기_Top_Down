import java.util.*;

/**
 * Dynamic Programming
 * Memoization DP
 * Top - Down (큰 문제 -> 작은 문제 : 재귀)
 *
 * Tabulation DP
 * Bottom - Up (작은 문제 -> 큰 문제 : 반복문)
 **/


/**
 * 부분 합
 * 각 원소의 인덱스까지의 합을 미리 배열로 계산해둔다
 * arr[4] = [2, 3, 7, 5]
 * sum[4] = [2, 5, 12, 17]
 * [1 ~ 3] 합 : sum[3] - sum[0]
 * ==> [i ~ j] 합 : sum[j] - sum[i-1]
 */
public class Main {

    //11066 파일 합치기
    //나는 Bottom - UP으로만 풀려고 한다
    final static Scanner sc = new Scanner(System.in);
    static int T; //TestCase
    static int K; //Chapter수

    static int[] novel;
    static int[][] dp;

    /***********/
    //앞에서부터 순서대로 합친 값
    static int[] sum;

    static void solution(){

        // dp[i][j]는 i chapter ~ j chapter까지 합한 최솟값
        // dp[i][i] = novel[i]
        // dp[i][i+1] = novel[i] + novel[i+1] : 앞에서부터 인접한 두 파일을 합친 값

        // dp[i][i+2]
        // dp[i][i] + dp[i+1][i+2] + (novel[i] + novel[i+1] + novel[i+2]),
        // dp[i][i+1] + dp[i+2][i+2] + (novel[i] + novel[i+1] + novel[i+2])
        // 중에 Min 값
        // ※ novel[i] + novel[i+1] + novel[i+2] : 결국 세 파일을 합치는 것이기 때문에

        // ==> 점화식
        // dp[i][j]
        // divide가 (i+1)부터 시작해서 (j-1)까지 순회하면서 비교했을 때
        // dp[i][i + divide] + dp[divide + 1][j] + sum(i ~ j까지 "부분 합")

        /**
         * for 1장부터 n장까지 묶기 n <= k(몇장을 묶을것인가?
         *      for 1부터 k까지 j + n <= k  (어디부터 묶기 시작할것인가)
         *          for 1부터 k까지 divide < j + n (범위가 주어졌을때 특정 지점으로 나눠서 최대값 구하기)
         */

        for(int n=1; n<=K; n++){
            for(int from = 1; from + n <= K; from++){
                int to = from + n;
                //Min을 비교하기 위한 MAX_VALUE

                dp[from][to] = Integer.MAX_VALUE;
                for(int divide = from; divide<to; divide++){
                    dp[from][to] = Math.min(
                            dp[from][to],
                            dp[from][divide] + dp[divide+1][to] + (sum[to] - sum[from-1]));
                }
            }
        }




    }
    public static void main(String[] args){

        T = sc.nextInt();

        for(int i=0; i<T; i++){
            K = sc.nextInt();

            novel = new int[K+1];
            dp  = new int[K+1][K+1];
            sum = new int[K+1];

            for(int j =1; j<=K; j++)
                novel[j] = sc.nextInt();

            for(int j =1; j<=K; j++)
                sum[j] = sum[j-1] + novel[j];



            solution();
            System.out.println(dp[1][K]);
        }


    }
}
