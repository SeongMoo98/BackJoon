import java.io.*;
import java.lang.reflect.Array;
import java.util.*;
import static java.lang.Math.*;

public class Main {
    final static Scanner sc = new Scanner(System.in);
    static int N, maxWeight;


    //https://st-lab.tistory.com/141
    public static void main(String[] args) throws IOException {

        BufferedReader br  = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        maxWeight = Integer.parseInt(st.nextToken());

        // 물건의 weight와 value저장
        // [0] : weight, [1] : value
        /* 쌍을 저장할 때 이런식으로 만들 생각을 못했다
         * 자주 봤던 코드인데
         * */
        int[][] item = new int[N+1][2];

        for(int i=1; i<=N; i++){
            st = new StringTokenizer(br.readLine());
            item[i][0] = Integer.parseInt(st.nextToken());
            item[i][1] = Integer.parseInt(st.nextToken());
        }

        // row : 아이템들 column : 무게 1 ~~~ K
        /* DP에서 몇차원으로 갈지 고민
         * 그리고 maxWeight와 값 비교만 하려하지말고
         * 쪼개서 DP Table을 구성하는 생각
         * */
        int[][] dp = new int[N+1][maxWeight+1];

        // 수용가능한 최대 무게에 따른 i까지의 각 물품의 무게 및 가치를 Table로 표현
        // row는 탐색했다는 의미 ==> i번째 물품을 담을 수 없을 때 dp[i][j] = dp[i-1][j]
       for(int i=1; i<=N; i++){
            for(int j=1; j<=maxWeight; j++){
                // i번째 무게를 더 담을 수 없는 경우
                if(item[i][0] > j){
                    dp[i][j] = dp[i-1][j];
                }
                // i번째 무게를 더 담을 수 있는 경우
                else{
                    dp[i][j] = Math.max(dp[i-1][j],
                            (dp[i-1][j - item[i][0]]) + item[i][1]);
                }
            }
        }
        System.out.println(dp[N][maxWeight]);

    }


}
